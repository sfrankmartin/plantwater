import { promises as fs } from 'fs'
import path from 'path'
import { v4 as uuidv4 } from 'uuid'
import { processImageSecurely, ProcessedImage } from './imageProcessing'

/**
 * Mock Cloud Storage Service
 * 
 * This service mocks a cloud storage provider (like AWS S3, Google Cloud Storage, etc.)
 * but actually stores files in the /public/uploads directory for the prototype.
 * 
 * In production, you would replace this implementation with actual cloud storage:
 * - AWS S3 with AWS SDK
 * - Google Cloud Storage with @google-cloud/storage
 * - Cloudinary with cloudinary package
 * - etc.
 * 
 * The interface remains the same, so switching to real cloud storage later
 * requires only changing this implementation, not the calling code.
 */

export interface CloudStorageService {
  uploadImageSecurely(file: File, baseFilename?: string): Promise<{
    imageUrl: string
    processedImage: ProcessedImage
  }>
  deleteImage(imageUrl: string): Promise<boolean>
  getImageUrl(filename: string): string
}

class MockCloudStorageService implements CloudStorageService {
  private uploadDir = path.join(process.cwd(), 'public', 'uploads', 'plants')

  constructor() {
    // Upload directory will be created on first use
  }

  private async ensureUploadDir() {
    try {
      await fs.access(this.uploadDir)
    } catch {
      await fs.mkdir(this.uploadDir, { recursive: true })
    }
  }

  async uploadImageSecurely(file: File, baseFilename?: string): Promise<{
    imageUrl: string
    processedImage: ProcessedImage
  }> {
    await this.ensureUploadDir()
    
    // Process image securely - validates, strips EXIF, converts to WebP
    const processedImage = await processImageSecurely(file, baseFilename)
    
    // Use the secure filename generated by processing
    const filePath = path.join(this.uploadDir, processedImage.filename)
    
    // Write the processed (secure) buffer
    await fs.writeFile(filePath, processedImage.buffer)
    
    // Return the secure API URL instead of direct public access
    const imageUrl = `/api/images/${processedImage.filename}`
    
    return {
      imageUrl,
      processedImage
    }
  }

  // Legacy method for backward compatibility - now redirects to secure version
  async uploadImage(file: File | Buffer, originalFilename: string): Promise<string> {
    if (file instanceof File) {
      const result = await this.uploadImageSecurely(file, path.parse(originalFilename).name)
      return result.imageUrl
    } else {
      // For Buffer uploads, we need to maintain some backward compatibility
      // but this is less secure - log a warning
      console.warn('SECURITY: Using legacy buffer upload method. Consider migrating to File-based uploads.')
      
      await this.ensureUploadDir()
      
      const fileExtension = path.extname(originalFilename)
      const filename = `${uuidv4()}${fileExtension}`
      const filePath = path.join(this.uploadDir, filename)
      
      await fs.writeFile(filePath, file)
      return `/api/images/${filename}`
    }
  }

  async deleteImage(imageUrl: string): Promise<boolean> {
    try {
      // Extract filename from URL (e.g., "/api/images/filename.webp" -> "filename.webp")
      const filename = imageUrl.split('/').pop()
      if (!filename) return false
      
      const filePath = path.join(this.uploadDir, filename)
      await fs.unlink(filePath)
      return true
    } catch (error) {
      console.error('Error deleting image:', error)
      return false
    }
  }

  getImageUrl(filename: string): string {
    // In a real cloud service, this would return the full cloud URL
    // e.g., https://your-bucket.s3.amazonaws.com/uploads/plants/filename.jpg
    return `/uploads/plants/${filename}`
  }
}

// Export singleton instance
export const cloudStorage = new MockCloudStorageService()

// TODO: Replace with real cloud storage implementation
// Example for AWS S3:
/*
import AWS from 'aws-sdk'

class S3CloudStorageService implements CloudStorageService {
  private s3: AWS.S3
  private bucket: string

  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    })
    this.bucket = process.env.S3_BUCKET_NAME!
  }

  async uploadImage(file: File | Buffer, originalFilename: string): Promise<string> {
    const fileExtension = path.extname(originalFilename)
    const filename = `plants/${uuidv4()}${fileExtension}`
    
    let buffer: Buffer
    if (file instanceof File) {
      const arrayBuffer = await file.arrayBuffer()
      buffer = Buffer.from(arrayBuffer)
    } else {
      buffer = file
    }

    const result = await this.s3.upload({
      Bucket: this.bucket,
      Key: filename,
      Body: buffer,
      ContentType: file instanceof File ? file.type : 'image/jpeg'
    }).promise()

    return result.Location
  }

  async deleteImage(imageUrl: string): Promise<boolean> {
    try {
      const key = imageUrl.split('/').slice(-2).join('/') // Extract key from URL
      await this.s3.deleteObject({
        Bucket: this.bucket,
        Key: key
      }).promise()
      return true
    } catch {
      return false
    }
  }

  getImageUrl(filename: string): string {
    return `https://${this.bucket}.s3.amazonaws.com/${filename}`
  }
}

export const cloudStorage = new S3CloudStorageService()
*/
